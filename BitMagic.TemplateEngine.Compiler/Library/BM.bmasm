library BitMagic.Helper.BM;
using System.Text;

public static void Bytes(IEnumerable<int> bytes, int width = 16) => Bytes(bytes.Select(i => (byte)i), width);

public static void Bytes(IEnumerable<sbyte> bytes, int width = 16) => Bytes(bytes.Select(i => unchecked((byte)i)), width);

public static void Bytes(IEnumerable<byte> bytes, int width = 16)
{
    StringBuilder sb = new StringBuilder();
    var cnt = 0;
    var first = true;
    foreach (var i in bytes)
    {
        if (first)
        {
            first = false;
        }
        else
        {
            sb.Append(", ");
        }

        sb.Append($"${i:X2}");
        cnt++;
        if (cnt == width)
        {
            .byte @(sb.ToString())
            sb.Clear();
            cnt = 0;
            first = true;
        }
    }

    if (!first) {
        .byte @(sb.ToString())
    }
}

public static void Bytes(string stringData) => Bytes(stringData.ToCharArray().Select(i => (byte)i));

public static void HighBytes(IEnumerable<int> words, int width = 16) => Bytes(words.Select(i => (i >> 8) & 0xff), width);
public static void HighBytes(IEnumerable<ushort> words, int width = 16) => Bytes(words.Select(i => (i >> 8) & 0xff), width);
public static void HighBytes(IEnumerable<short> words, int width = 16) => Bytes(words.Select(i => (i >> 8) & 0xff), width);

public static void LowBytes(IEnumerable<int> words, int width = 16) => Bytes(words.Select(i => i & 0xff), width);
public static void LowBytes(IEnumerable<ushort> words, int width = 16) => Bytes(words.Select(i => i & 0xff), width);
public static void LowBytes(IEnumerable<short> words, int width = 16) => Bytes(words.Select(i => i & 0xff), width);


public static void Words(IEnumerable<ushort> words, int width = 16)
{
    StringBuilder sb = new StringBuilder();
    var cnt = 0;
    var first = true;
    foreach (var i in words)
    {
        if (first)
        {
            first = false;
        }
        else
        {
            sb.Append(", ");
        }

        sb.Append($"${i:X4}");
        cnt++;
        if (cnt == width)
        {
            .word @(sb.ToString())
            sb.Clear();
            cnt = 0;
            first = true;
        }
    }

    if (!first) {
        .word @(sb.ToString())
    }
}

public static void Words(IEnumerable<short> words, int width = 16)
{
    StringBuilder sb = new StringBuilder();
    var cnt = 0;
    var first = true;
    foreach (var i in words)
    {
        if (first)
        {
            first = false;
        }
        else
        {
            sb.Append(", ");
        }

        sb.Append($"${i:X4}");
        cnt++;
        if (cnt == width)
        {
            .word @(sb.ToString())
            sb.Clear();
            cnt = 0;
            first = true;
        }
    }

    if (!first) {
        .word @(sb.ToString())
    }
}

//    .byte $0C, $08              ; $080C - pointer to next line of BASIC code
//    .byte $0A, $00              ; 2-byte line number($000A = 10)
//    .byte $9E                   ; SYS BASIC token
//    .byte $20                   ; [space] ; REMOVED
//    .byte $32, $30, $36, $31    ; $32="2",$30="0",$36="6",$31="1"
//    .byte $00                   ; End of Line
//    .byte $00, $00              ; This is address $080C containing
//                                ; 2-byte pointer to next line of BASIC code
//                                ; ($0000 = end of program)
public static void X16Header() => Bytes(new byte[] { 0x0c, 0x08, 0x0a, 0x00, 0x9e, 0x32, 0x30, 0x36, 0x31, 0x00, 0x00, 0x00 });

public static void X16Header(string startLabel, bool invalidHeader = false) 
{
    .byte 0x0c, 0x08, 0x0a, 0x00, 0x9e
    .byte @(startLabel) % 10000 / 1000 + $30
    .byte @(startLabel) % 1000  / 100  + $30
    .byte @(startLabel) % 100   / 10   + $30
    .byte @(startLabel) % 10           + $30
    .byte 0x00
    if (!invalidHeader)
    {
    .byte 0x00, 0x00;
    }
}

public static void X16Header(int startLabel, bool invalidHeader = false) 
{
    .byte 0x0c, 0x08, 0x0a, 0x00, 0x9e
    .byte @(startLabel) % 10000 / 1000 + $30
    .byte @(startLabel) % 1000  / 100  + $30
    .byte @(startLabel) % 100   / 10   + $30
    .byte @(startLabel) % 10           + $30
    .byte 0x00
    if (!invalidHeader)
    {
    .byte 0x00, 0x00;
    }
}

public static void Petscii(string input, bool addNullTermination = true) => Bytes(StringToPetscii(input, addNullTermination));

public static IEnumerable<byte> StringToPetscii(string input, bool addNullTermination = true)
{
    for(var i = 0; i < input.Length; i++)
    {
        yield return (byte)input[i];
    }

    if (addNullTermination)
        yield return 0x00;
}

public static void IsoPetscii(string input, bool addNullTermination = true) => Bytes(IsoStringToPetscii(input, addNullTermination));

private static IEnumerable<byte> IsoStringToPetscii(string input, bool addNullTermination = true)
{
    for(var i = 0; i < input.Length; i++)
    {
        var val = (byte)input[i];

        if (val >= 0x40 && val < 0x60)
            val -= 0x40;

        yield return val;
    }

    if (addNullTermination)
        yield return 0x00;
}
